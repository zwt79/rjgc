

<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>å¦å…‹å¤§æˆ˜ Â· éœ“è™¹æˆ˜åœº</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body class="game-page">
    <div class="game-stage">
      <canvas id="game" width="768" height="432"></canvas>
      <div class="game-overlay">
        <div class="game-overlay__top">
          <div class="game-actions">
            <a class="btn btn--primary btn--pill" href="{{ url_for('main_menu') }}">â¬… è¿”å›ä¸»èœå•</a>
            <a class="btn btn--ghost btn--pill" href="{{ url_for('help') }}">ğŸ“˜ æ“ä½œæ‰‹å†Œ</a>
          </div>
          <div class="game-stats">
            <div class="hud-stat">
              <span class="hud-stat__label">ç”Ÿå‘½</span>
              <span class="hud-stat__value" data-hud="lives">3</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat__label">åˆ†æ•°</span>
              <span class="hud-stat__value" data-hud="score">0</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat__label">å…³å¡</span>
              <span class="hud-stat__value" data-hud="level">1</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat__label">æ•Œäºº</span>
              <span class="hud-stat__value" data-hud="enemies">0</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat__label">æ³¢æ¬¡</span>
              <span class="hud-stat__value" data-hud="wave">1/4</span>
            </div>
            <div class="hud-stat hud-stat--compact">
              <span class="hud-stat__label">FPS</span>
              <span class="hud-stat__value" data-hud="fps">-</span>
            </div>
          </div>
        </div>
        <div class="game-overlay__bottom">
          <div class="hud-banner">
            <span class="hud-banner__label">æŒ‰é”®</span>
            <span class="hud-banner__value" data-hud="keys">-</span>
          </div>
          <div class="hud-banner hud-banner--ghost">
            <span class="hud-banner__label">æç¤º</span>
            <span class="hud-banner__value">Esc æš‚åœ Â· R é‡ç½®</span>
          </div>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const HUD_KEYS = ['lives', 'score', 'level', 'enemies', 'wave', 'keys', 'fps'];
      const hudRegistry = HUD_KEYS.reduce((acc, key) => {
        acc[key] = Array.from(document.querySelectorAll(`[data-hud="${key}"]`));
        return acc;
      }, {});
      const setHUD = (key, value) => {
        (hudRegistry[key] || []).forEach(node => {
          node.textContent = value;
        });
      };
      const VIEWPORT_PADDING = 120;
      let mapPixelWidth = 0;
      let mapPixelHeight = 0;
      const queryParams = new URLSearchParams(window.location.search);
      const defaultLevelId = Number.parseInt(queryParams.get('level') || '1', 10);
      let currentLevelId = Number.isFinite(defaultLevelId) && defaultLevelId > 0 ? defaultLevelId : 1;
      window.addEventListener('resize', () => {
        if (mapPixelWidth && mapPixelHeight) {
          resizeViewport(mapPixelWidth, mapPixelHeight, { adjustExisting: true });
        }
      });

      let W = canvas.width, H = canvas.height; // æ³¨æ„ï¼šå…³å¡åŠ è½½åä¼šè°ƒæ•´å°ºå¯¸
      const tank = { x: W/2, y: H/2, w: 18, h: 18, speed: 100, dir:'up', fireCooldown: 0.0 };
      let level = null; // å…³å¡æ•°æ®
      const bullets = [];
      const enemies = []; // æ•Œäººæ•°ç»„
      let enemyTypes = {}; // æ•Œäººç±»å‹é…ç½®
      let enemyWaves = []; // æ•Œäººæ³¢æ¬¡æ•°æ®
      let currentWave = 0; // å½“å‰æ³¢æ¬¡
      let waveTimer = 0; // æ³¢æ¬¡è®¡æ—¶å™¨
      let enemiesSpawned = 0; // å·²ç”Ÿæˆæ•Œäººæ•°
      let levelOffsetX = 0, levelOffsetY = 0; // åœ°å›¾åœ¨ç”»å¸ƒä¸­çš„åç§»ï¼Œç”¨äºå®šä½ä¸ç¢°æ’
      function resizeViewport(mapWidth = mapPixelWidth, mapHeight = mapPixelHeight, options = {}) {
        if (!mapWidth || !mapHeight) return;
        const { adjustExisting = true } = options;
        const prevOffsetX = levelOffsetX;
        const prevOffsetY = levelOffsetY;
        const padding = VIEWPORT_PADDING;
        const viewportWidth = Math.max(window.innerWidth, mapWidth + padding);
        const viewportHeight = Math.max(window.innerHeight, mapHeight + padding);
        canvas.width = viewportWidth;
        canvas.height = viewportHeight;
        W = canvas.width;
        H = canvas.height;
        levelOffsetX = Math.floor((canvas.width - mapWidth) / 2);
        levelOffsetY = Math.floor((canvas.height - mapHeight) / 2);
        if (levelOffsetY < 0) levelOffsetY = 0;

        if (adjustExisting) {
          const dx = levelOffsetX - prevOffsetX;
          const dy = levelOffsetY - prevOffsetY;
          if (dx !== 0 || dy !== 0) {
            tank.x += dx;
            tank.y += dy;
            bullets.forEach(b => { b.x += dx; b.y += dy; });
            enemies.forEach(e => { e.x += dx; e.y += dy; });
            explosions.forEach(ex => { ex.x += dx; ex.y += dy; });
            particles.forEach(p => { p.x += dx; p.y += dy; });
            powerups.forEach(pu => { pu.x += dx; pu.y += dy; });
            if (base) {
              base.x += dx;
              base.y += dy;
            }
          }
        }
      }
      const input = { up:false, down:false, left:false, right:false };
      
      // æ¸¸æˆçŠ¶æ€
      let gameState = 'playing'; // playing, paused, gameOver, victory
      let playerLives = 3;
      let score = 0;
      let base = null; // åŸºåœ°å¯¹è±¡
      
      // çˆ†ç‚¸ç‰¹æ•ˆç³»ç»Ÿ
      const explosions = []; // çˆ†ç‚¸æ•ˆæœæ•°ç»„
      const particles = []; // ç²’å­ç³»ç»Ÿ
      let screenShake = { x: 0, y: 0, intensity: 0, duration: 0 }; // å±å¹•éœ‡åŠ¨
      
      // é“å…·ç³»ç»Ÿ
      const powerups = []; // é“å…·æ•°ç»„
      let powerupSpawnChance = 0.3; // æ•Œäººæ­»äº¡æ—¶30%æ¦‚ç‡æ‰è½é“å…·
      
      // éŸ³æ•ˆç³»ç»Ÿ
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const sounds = {
        shoot: null,
        explosion: null,
        hit: null,
        powerup: null,
        gameOver: null,
        victory: null
      };
      let masterVolume = 0.8;
      let sfxVolume = 0.9;
      let musicVolume = 0.7;
      let backgroundMusic = null;

      function drawTank(){
        ctx.save();
        ctx.translate(tank.x, tank.y);
        ctx.rotate(tank.dir === 'up' ? 0 : tank.dir === 'down' ? Math.PI : tank.dir === 'left' ? -Math.PI/2 : Math.PI/2);
        
        const w = tank.w;
        const h = tank.h;
        
        // ç©å®¶å¦å…‹ - è“è‰²ä¸»é¢˜ï¼Œç°ä»£åŒ–è®¾è®¡
        // ä¸»ä½“æ¸å˜
        const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
        gradient.addColorStop(0, '#38bdf8');
        gradient.addColorStop(0.5, '#0ea5e9');
        gradient.addColorStop(1, '#0284c7');
        ctx.fillStyle = gradient;
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // è¾¹æ¡†
        ctx.strokeStyle = '#0369a1';
        ctx.lineWidth = 2;
        ctx.strokeRect(-w/2, -h/2, w, h);
        
        // å†…éƒ¨ç»†èŠ‚
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(-w/2 + 3, -h/2 + 3, w - 6, h - 6);
        
        // ç‚®ç®¡
        ctx.fillStyle = '#374151';
        ctx.fillRect(-2, -h/2 - 4, 4, 8);
        
        // ç‚®ç®¡å°–ç«¯
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(-1, -h/2 - 6, 2, 4);
        
        // å±¥å¸¦ç»†èŠ‚
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(-w/2 + 2, -h/2 + 1, w - 4, 2);
        ctx.fillRect(-w/2 + 2, h/2 - 3, w - 4, 2);
        
        // ç©å®¶æ ‡è¯†
        ctx.fillStyle = '#fbbf24';
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('P', 0, 2);
        
        ctx.restore();
      }

      let last = performance.now();
      let acc = 0; const FIXED_DT = 1/60;
      let fpsTimer = 0; let frames = 0;

      function update(dt){
        // æš‚åœæ—¶ä¸æ›´æ–°æ¸¸æˆé€»è¾‘
        if (gameState !== 'playing') {
          updateHUD();
          return;
        }

        const dx = (input.right - input.left) * tank.speed * dt;
        const dy = (input.down - input.up) * tank.speed * dt;

        // å…ˆæŒ‰ X è½´å°è¯•ç§»åŠ¨ï¼Œå†æŒ‰ Y è½´ï¼Œå¸¦ç“¦ç‰‡ç¢°æ’å’Œè¾¹ç•Œæ£€æµ‹
        let nextX = tank.x + dx;
        // è¾¹ç•Œæ£€æµ‹ï¼šç¡®ä¿å¦å…‹ä¸ä¼šè¶…å‡ºç”»å¸ƒè¾¹ç•Œ
        nextX = Math.max(tank.w/2, Math.min(canvas.width - tank.w/2, nextX));
        if (!willCollide(nextX, tank.y)) tank.x = nextX;

        let nextY = tank.y + dy;
        // è¾¹ç•Œæ£€æµ‹ï¼šç¡®ä¿å¦å…‹ä¸ä¼šè¶…å‡ºç”»å¸ƒè¾¹ç•Œ
        nextY = Math.max(tank.h/2, Math.min(canvas.height - tank.h/2, nextY));
        if (!willCollide(tank.x, nextY)) tank.y = nextY;

        // æ–¹å‘
        if (Math.abs(dx) > Math.abs(dy)){
          if (dx > 0) tank.dir = 'right';
          else if (dx < 0) tank.dir = 'left';
        } else if (Math.abs(dy) > 0) {
          if (dy > 0) tank.dir = 'down';
          else if (dy < 0) tank.dir = 'up';
        }

        // å†·å´
        tank.fireCooldown = Math.max(0, tank.fireCooldown - dt);

        // å­å¼¹å¯¹æ’æ£€æµ‹ï¼ˆåœ¨æ›´æ–°ä½ç½®ä¹‹å‰ï¼‰



        checkBulletToBulletCollision();
        
        // å­å¼¹æ›´æ–°
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt; b.y += b.vy * dt;
          
          // æ£€æŸ¥ä¸å•ä½ç¢°æ’
          if (checkBulletUnitCollision(b)) { bullets.splice(i,1); continue; }
          
          // æ£€æŸ¥ä¸ç“¦ç‰‡ç¢°æ’
          if (checkBulletCollision(b)) { bullets.splice(i,1); continue; }
          
          // æ£€æŸ¥è¾¹ç•Œ
          if (b.x < 0 || b.y < 0 || b.x > canvas.width || b.y > canvas.height) bullets.splice(i,1);
        }

        // æ•Œäººç”Ÿæˆ
        updateEnemySpawning(dt);

        // æ•Œäººæ›´æ–°
        for (let i = enemies.length - 1; i >= 0; i--) {
          const enemy = enemies[i];
          updateEnemy(enemy, dt);
          if (enemy.health <= 0) {
            // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
            const explosionType = enemy.type === 'heavy' ? 'large' : enemy.type === 'special' ? 'large' : 'medium';
            const explosionColor = enemy.type === 'special' ? '#fbbf24' : '#ff6b35';
            createExplosion(enemy.x, enemy.y, explosionType, explosionColor);
            
            // éšæœºæ‰è½é“å…·
            if (Math.random() < powerupSpawnChance) {
              const powerupTypes = ['tank', 'star', 'helmet', 'shovel', 'bomb', 'gun'];
              const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
              createPowerup(enemy.x, enemy.y, randomType);
            }
            
            score += getEnemyScore(enemy.type);
            enemies.splice(i, 1);
          }
        }

        // æ›´æ–°çˆ†ç‚¸ç‰¹æ•ˆ
        updateExplosions(dt);
        updateParticles(dt);
        updateScreenShake(dt);
        
        // æ›´æ–°é“å…·
        updatePowerups(dt);
        
        // æ£€æŸ¥é“å…·æ‹¾å–
        checkPowerupCollection();

        // æ£€æŸ¥æ¸¸æˆçŠ¶æ€
        checkGameState();
        
        // æ›´æ–° HUD
        updateHUD();
      }

      // ========== çˆ†ç‚¸ç‰¹æ•ˆç³»ç»Ÿ ==========
      
      /**
       * åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
       * @param {number} x - Xåæ ‡
       * @param {number} y - Yåæ ‡
       * @param {string} type - çˆ†ç‚¸ç±»å‹ ('small', 'medium', 'large', 'brick')
       * @param {string} color - ä¸»è¦é¢œè‰²
       */
      function createExplosion(x, y, type = 'medium', color = '#ff6b35') {
        const config = {
          small: { radius: 20, particles: 8, duration: 0.3, rings: 2 },
          medium: { radius: 35, particles: 16, duration: 0.5, rings: 3 },
          large: { radius: 50, particles: 24, duration: 0.7, rings: 4 },
          brick: { radius: 15, particles: 6, duration: 0.25, rings: 1 }
        };
        
        const cfg = config[type] || config.medium;
        
        explosions.push({
          x, y,
          maxRadius: cfg.radius,
          currentRadius: 0,
          duration: cfg.duration,
          elapsed: 0,
          rings: cfg.rings,
          color: color,
          type: type
        });
        
        // åˆ›å»ºç²’å­
        createParticles(x, y, cfg.particles, color, type);
        
        // æ ¹æ®çˆ†ç‚¸å¤§å°è§¦å‘å±å¹•éœ‡åŠ¨å’ŒéŸ³æ•ˆ
        if (type === 'large') {
          triggerScreenShake(8, 0.3);
          generateExplosionSound('large');
        } else if (type === 'medium') {
          triggerScreenShake(4, 0.2);
          generateExplosionSound('medium');
        } else if (type === 'small') {
          triggerScreenShake(2, 0.1);
          generateExplosionSound('small');
        } else if (type === 'brick') {
          generateHitSound();
        }
      }
      
      /**
       * åˆ›å»ºç²’å­æ•ˆæœ
       * @param {number} x - Xåæ ‡
       * @param {number} y - Yåæ ‡
       * @param {number} count - ç²’å­æ•°é‡
       * @param {string} color - ç²’å­é¢œè‰²
       * @param {string} type - æ•ˆæœç±»å‹
       */
      function createParticles(x, y, count, color, type) {
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
          const speed = type === 'brick' ? 50 + Math.random() * 50 : 100 + Math.random() * 100;
          const size = type === 'brick' ? 2 + Math.random() * 2 : 3 + Math.random() * 3;
          
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            life: 0.5 + Math.random() * 0.5,
            maxLife: 0.5 + Math.random() * 0.5,
            color: color,
            gravity: type === 'brick' ? 200 : 150
          });
        }
      }
      
      /**
       * è§¦å‘å±å¹•éœ‡åŠ¨
       * @param {number} intensity - éœ‡åŠ¨å¼ºåº¦
       * @param {number} duration - æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
       */
      function triggerScreenShake(intensity, duration) {
        if (screenShake.intensity < intensity) {
          screenShake.intensity = intensity;
          screenShake.duration = duration;
        }
      }
      
      /**
       * æ›´æ–°çˆ†ç‚¸æ•ˆæœ
       * @param {number} dt - æ—¶é—´å¢é‡
       */
      function updateExplosions(dt) {
        for (let i = explosions.length - 1; i >= 0; i--) {
          const exp = explosions[i];
          exp.elapsed += dt;
          
          // æ›´æ–°çˆ†ç‚¸åŠå¾„
          const progress = exp.elapsed / exp.duration;
          exp.currentRadius = exp.maxRadius * Math.min(progress * 1.5, 1);
          
          // ç§»é™¤å·²å®Œæˆçš„çˆ†ç‚¸
          if (exp.elapsed >= exp.duration) {
            explosions.splice(i, 1);
          }
        }
      }
      
      /**
       * æ›´æ–°ç²’å­æ•ˆæœ
       * @param {number} dt - æ—¶é—´å¢é‡
       */
      function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          
          // æ›´æ–°ä½ç½®
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          
          // åº”ç”¨é‡åŠ›
          p.vy += p.gravity * dt;
          
          // å‡å°‘ç”Ÿå‘½å€¼
          p.life -= dt;
          
          // ç§»é™¤å·²æ­»äº¡çš„ç²’å­
          if (p.life <= 0) {
            particles.splice(i, 1);
          }
        }
      }
      
      /**
       * æ›´æ–°å±å¹•éœ‡åŠ¨
       * @param {number} dt - æ—¶é—´å¢é‡
       */
      function updateScreenShake(dt) {
        if (screenShake.duration > 0) {
          screenShake.duration -= dt;
          
          if (screenShake.duration <= 0) {
            screenShake.x = 0;
            screenShake.y = 0;
            screenShake.intensity = 0;
          } else {
            // éšæœºéœ‡åŠ¨åç§»
            screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
            screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
          }
        }
      }
      
      /**
       * ç»˜åˆ¶çˆ†ç‚¸æ•ˆæœ
       */
      function drawExplosions() {
        for (const exp of explosions) {
          const progress = exp.elapsed / exp.duration;
          const alpha = 1 - progress;
          
          ctx.save();
          ctx.globalAlpha = alpha;
          
          // ç»˜åˆ¶å¤šå±‚çˆ†ç‚¸ç¯
          for (let ring = 0; ring < exp.rings; ring++) {
            const ringProgress = Math.max(0, progress - ring * 0.2);
            const radius = exp.currentRadius * ringProgress;
            
            // å¤–ç¯ - äº®è‰²
            const gradient = ctx.createRadialGradient(exp.x, exp.y, 0, exp.x, exp.y, radius);
            gradient.addColorStop(0, exp.color + 'ff');
            gradient.addColorStop(0.4, exp.color + 'aa');
            gradient.addColorStop(0.7, exp.color + '44');
            gradient.addColorStop(1, exp.color + '00');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // ä¸­å¿ƒé—ªå…‰
          if (progress < 0.3) {
            const flashAlpha = (0.3 - progress) / 0.3;
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, exp.maxRadius * 0.3, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.restore();
        }
      }
      
      /**
       * ç»˜åˆ¶ç²’å­æ•ˆæœ
       */
      function drawParticles() {
        for (const p of particles) {
          const alpha = p.life / p.maxLife;
          
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          // æ·»åŠ è½¨è¿¹æ•ˆæœ
          ctx.globalAlpha = alpha * 0.3;
          ctx.beginPath();
          ctx.arc(p.x - p.vx * 0.02, p.y - p.vy * 0.02, p.size * 0.7, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
      }

      // ========== é“å…·ç³»ç»Ÿ ==========
      
      /**
       * åˆ›å»ºé“å…·
       * @param {number} x - Xåæ ‡
       * @param {number} y - Yåæ ‡
       * @param {string} type - é“å…·ç±»å‹
       */
      function createPowerup(x, y, type = 'tank') {
        const config = {
          tank: { 
            color: '#22c55e', 
            icon: 'ğŸ–ï¸', 
            duration: 10, 
            effect: 'ç”Ÿå‘½+1',
            size: 16
          },
          star: { 
            color: '#fbbf24', 
            icon: 'â­', 
            duration: 10, 
            effect: 'å‡çº§',
            size: 16
          },
          helmet: { 
            color: '#60a5fa', 
            icon: 'ğŸ›¡ï¸', 
            duration: 10, 
            effect: 'æ— æ•Œ',
            size: 16
          },
          shovel: { 
            color: '#94a3b8', 
            icon: 'ğŸ”¨', 
            duration: 10, 
            effect: 'åŠ å›ºåŸºåœ°',
            size: 16
          },
          bomb: { 
            color: '#ef4444', 
            icon: 'ğŸ’£', 
            duration: 10, 
            effect: 'æ¸…å±',
            size: 16
          },
          gun: { 
            color: '#8b5cf6', 
            icon: 'ğŸ”«', 
            duration: 10, 
            effect: 'é«˜å¨åŠ›',
            size: 16
          }
        };
        
        const cfg = config[type] || config.tank;
        
        powerups.push({
          x, y,
          type: type,
          color: cfg.color,
          icon: cfg.icon,
          effect: cfg.effect,
          size: cfg.size,
          lifetime: cfg.duration,
          elapsed: 0,
          bobOffset: Math.random() * Math.PI * 2 // ä¸Šä¸‹æµ®åŠ¨åç§»
        });
      }
      
      /**
       * æ›´æ–°é“å…·
       * @param {number} dt - æ—¶é—´å¢é‡
       */
      function updatePowerups(dt) {
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          p.elapsed += dt;
          
          // ç§»é™¤è¿‡æœŸçš„é“å…·
          if (p.elapsed >= p.lifetime) {
            powerups.splice(i, 1);
          }
        }
      }
      
      /**
       * æ£€æŸ¥é“å…·æ‹¾å–
       */
      function checkPowerupCollection() {
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          
          // æ£€æŸ¥ç©å®¶æ˜¯å¦ç¢°åˆ°é“å…·
          const dx = tank.x - p.x;
          const dy = tank.y - p.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < (tank.w / 2 + p.size / 2)) {
            // æ‹¾å–é“å…·
            applyPowerup(p.type);
            
            // æ’­æ”¾æ‹¾å–éŸ³æ•ˆ
            generatePowerupSound();
            
            // åˆ›å»ºæ‹¾å–ç‰¹æ•ˆ
            createExplosion(p.x, p.y, 'small', p.color);
            createParticles(p.x, p.y, 12, p.color, 'small');
            
            // ç§»é™¤é“å…·
            powerups.splice(i, 1);
          }
        }
      }
      
      /**
       * åº”ç”¨é“å…·æ•ˆæœ
       * @param {string} type - é“å…·ç±»å‹
       */
      function applyPowerup(type) {
        switch(type) {
          case 'tank':
            // ç”Ÿå‘½+1
            playerLives++;
            console.log('æ‹¾å–å¦å…‹é“å…·ï¼ç”Ÿå‘½+1ï¼Œå½“å‰ç”Ÿå‘½:', playerLives);
            break;
          case 'star':
            // å‡çº§ï¼ˆæš‚æ—¶åªå¢åŠ åˆ†æ•°ï¼‰
            score += 500;
            console.log('æ‹¾å–æ˜Ÿæ˜Ÿé“å…·ï¼å¾—åˆ†+500');
            break;
          case 'helmet':
            // æ— æ•Œæ•ˆæœï¼ˆå¾…å®ç°ï¼‰
            console.log('æ‹¾å–å¤´ç›”é“å…·ï¼è·å¾—æ— æ•Œ');
            break;
          case 'shovel':
            // åŠ å›ºåŸºåœ°ï¼ˆå¾…å®ç°ï¼‰
            console.log('æ‹¾å–é”¹é“å…·ï¼åŸºåœ°åŠ å›º');
            break;
          case 'bomb':
            // æ¸…å±
            console.log('æ‹¾å–ç‚¸å¼¹é“å…·ï¼æ¸…é™¤æ‰€æœ‰æ•Œäºº');
            // æ¸…é™¤æ‰€æœ‰æ•Œäººå¹¶åˆ›å»ºçˆ†ç‚¸
            for (const enemy of enemies) {
              createExplosion(enemy.x, enemy.y, 'large', '#ef4444');
              score += getEnemyScore(enemy.type);
            }
            enemies.splice(0);
            triggerScreenShake(10, 0.4);
            break;
          case 'gun':
            // é«˜å¨åŠ›å¼¹ï¼ˆå¾…å®ç°ï¼‰
            console.log('æ‹¾å–æªé“å…·ï¼è·å¾—é«˜å¨åŠ›å¼¹');
            break;
        }
      }
      
      /**
       * ç»˜åˆ¶é“å…·
       */
      function drawPowerups() {
        for (const p of powerups) {
          // ä¸Šä¸‹æµ®åŠ¨æ•ˆæœ
          const bobAmount = Math.sin(p.elapsed * 3 + p.bobOffset) * 3;
          const drawY = p.y + bobAmount;
          
          ctx.save();
          
          // ç»˜åˆ¶å‘å…‰èƒŒæ™¯
          const gradient = ctx.createRadialGradient(p.x, drawY, 0, p.x, drawY, p.size);
          gradient.addColorStop(0, p.color + 'ff');
          gradient.addColorStop(0.5, p.color + '88');
          gradient.addColorStop(1, p.color + '00');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, drawY, p.size, 0, Math.PI * 2);
          ctx.fill();
          
          // ç»˜åˆ¶é“å…·ä¸»ä½“
          ctx.fillStyle = p.color;
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(p.x, drawY, p.size * 0.6, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
          
          // ç»˜åˆ¶å›¾æ ‡
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(p.icon, p.x, drawY);
          
          // ç»˜åˆ¶å‰©ä½™æ—¶é—´æç¤º
          const timeLeft = p.lifetime - p.elapsed;
          if (timeLeft < 3) {
            // æœ€å3ç§’é—ªçƒ
            const flash = Math.sin(p.elapsed * 10) > 0;
            if (flash) {
              ctx.globalAlpha = 0.7;
              ctx.fillStyle = '#ef4444';
              ctx.font = '10px Arial';
              ctx.fillText(Math.ceil(timeLeft), p.x, drawY - p.size - 5);
            }
          }
          
          ctx.restore();
        }
      }

      // ========== éŸ³æ•ˆç³»ç»Ÿ ==========
      
      /**
       * ç”Ÿæˆå°„å‡»éŸ³æ•ˆ
       */
      function generateShootSound() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(220, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1);
        
        gainNode.gain.setValueAtTime(sfxVolume * masterVolume * 0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.1);
      }
      
      /**
       * ç”Ÿæˆçˆ†ç‚¸éŸ³æ•ˆ
       */
      function generateExplosionSound(type = 'medium') {
        const duration = type === 'large' ? 0.5 : type === 'medium' ? 0.3 : 0.15;
        const volume = type === 'large' ? 0.4 : type === 'medium' ? 0.3 : 0.2;
        
        // ä½é¢‘éš†éš†å£°
        const noise = audioContext.createBufferSource();
        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        noise.buffer = buffer;
        
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(1000, audioContext.currentTime);
        filter.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + duration);
        
        const gainNode = audioContext.createGain();
        gainNode.gain.setValueAtTime(sfxVolume * masterVolume * volume, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        
        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        noise.start(audioContext.currentTime);
        noise.stop(audioContext.currentTime + duration);
      }
      
      /**
       * ç”Ÿæˆå‘½ä¸­éŸ³æ•ˆ
       */
      function generateHitSound() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'sawtooth';
        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.05);
        
        gainNode.gain.setValueAtTime(sfxVolume * masterVolume * 0.2, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.05);
      }
      
      /**
       * ç”Ÿæˆæ‹¾å–é“å…·éŸ³æ•ˆ
       */
      function generatePowerupSound() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
        oscillator.frequency.exponentialRampToValueAtTime(1320, audioContext.currentTime + 0.2);
        
        gainNode.gain.setValueAtTime(sfxVolume * masterVolume * 0.25, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 0.2);
      }
      
      /**
       * ç”Ÿæˆæ¸¸æˆç»“æŸéŸ³æ•ˆ
       */
      function generateGameOverSound() {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.type = 'triangle';
        oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.5);
        oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 1.0);
        
        gainNode.gain.setValueAtTime(sfxVolume * masterVolume * 0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.0);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + 1.0);
      }
      
      /**
       * ç”Ÿæˆèƒœåˆ©éŸ³æ•ˆ
       */
      function generateVictorySound() {
        const notes = [262, 330, 392, 523]; // C-E-G-Cå’Œå¼¦
        notes.forEach((freq, index) => {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + index * 0.1);
          
          gainNode.gain.setValueAtTime(0, audioContext.currentTime + index * 0.1);
          gainNode.gain.linearRampToValueAtTime(sfxVolume * masterVolume * 0.2, audioContext.currentTime + index * 0.1 + 0.05);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + index * 0.1 + 0.5);
          
          oscillator.start(audioContext.currentTime + index * 0.1);
          oscillator.stop(audioContext.currentTime + index * 0.1 + 0.5);
        });
      }
      
      /**
       * ä»è®¾ç½®ä¸­åŠ è½½éŸ³é‡
       */
      function loadAudioSettings() {
        const saved = localStorage.getItem('tankBattleSettings');
        if (saved) {
          const settings = JSON.parse(saved);
          masterVolume = (settings.masterVolume || 80) / 100;
          sfxVolume = (settings.sfxVolume || 90) / 100;
          musicVolume = (settings.musicVolume || 70) / 100;
        }
      }

      function render(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
        
        // åº”ç”¨å±å¹•éœ‡åŠ¨æ•ˆæœ
        ctx.save();
        ctx.translate(screenShake.x, screenShake.y);
        
        // èƒŒæ™¯ç½‘æ ¼
        ctx.strokeStyle = '#1e293b';
        ctx.lineWidth = 1;
        for(let x=0;x<canvas.width;x+=16){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
        for(let y=0;y<canvas.height;y+=16){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
        // ç“¦ç‰‡æ¸²æŸ“ï¼ˆè‹¥å…³å¡å­˜åœ¨ï¼‰
        if(level){
          const [gw, gh] = level.size;
          const ts = level.tile_size;
          const colors = { brick:'#b45309', steel:'#94a3b8', grass:'#14532d', water:'#0369a1', ice:'#93c5fd', ground:'#0b1220' };
          const ox = levelOffsetX;
          const oy = levelOffsetY;
          for(let y=0;y<gh;y++){
            for(let x=0;x<gw;x++){
              const t = level.tiles[y][x];
              ctx.fillStyle = colors[t] || '#0b1220';
              ctx.fillRect(ox + x*ts, oy + y*ts, ts, ts);
            }
          }
        }
        // å­å¼¹ - ä¼˜åŒ–æ ·å¼
        for (const b of bullets) {
          ctx.save();
          ctx.translate(b.x, b.y);
          
          // æ ¹æ®å­å¼¹æ‰€æœ‰è€…è®¾ç½®é¢œè‰²
          if (b.owner === 'player') {
            // ç©å®¶å­å¼¹ - è“è‰²
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 3);
            gradient.addColorStop(0, '#60a5fa');
            gradient.addColorStop(0.7, '#3b82f6');
            gradient.addColorStop(1, '#1d4ed8');
            ctx.fillStyle = gradient;
          } else {
            // æ•Œäººå­å¼¹ - çº¢è‰²
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 3);
            gradient.addColorStop(0, '#f87171');
            gradient.addColorStop(0.7, '#ef4444');
            gradient.addColorStop(1, '#dc2626');
            ctx.fillStyle = gradient;
          }
          
          // ç»˜åˆ¶åœ†å½¢å­å¼¹
          ctx.beginPath();
          ctx.arc(0, 0, 3, 0, Math.PI * 2);
          ctx.fill();
          
          // æ·»åŠ å‘å…‰æ•ˆæœ
          ctx.shadowColor = ctx.fillStyle;
          ctx.shadowBlur = 4;
          ctx.beginPath();
          ctx.arc(0, 0, 2, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
        
        // æ•Œäºº
        for (const enemy of enemies) {
          drawEnemy(enemy);
        }
        
        // åŸºåœ°
        if (base) {
          drawBase();
        }
        
        drawTank();
        
        // ç»˜åˆ¶é“å…·
        drawPowerups();
        
        // ç»˜åˆ¶çˆ†ç‚¸å’Œç²’å­æ•ˆæœï¼ˆåœ¨å¦å…‹å’Œæ•Œäººä¹‹åï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚ï¼‰
        drawParticles();
        drawExplosions();
        
        // æ¢å¤å±å¹•éœ‡åŠ¨çš„å˜æ¢
        ctx.restore();
        
        // æ¸¸æˆçŠ¶æ€æ˜¾ç¤ºï¼ˆä¸å—å±å¹•éœ‡åŠ¨å½±å“ï¼‰
        if (gameState !== 'playing') {
          drawGameState();
        }
      }

      function loop(now){
        let dt = (now - last)/1000; last = now;
        acc += Math.min(dt, 0.25);
        while(acc >= FIXED_DT){ update(FIXED_DT); acc -= FIXED_DT; }
        render();
        frames++; fpsTimer += dt; if (fpsTimer >= 0.5){ setHUD('fps', (frames/fpsTimer).toFixed(0)); frames = 0; fpsTimer = 0; }
        requestAnimationFrame(loop);
      }

      function setKey(e, down){
        const k = e.key.toLowerCase();
        
        // è°ƒè¯•ä¿¡æ¯
        if (down && k === 'r') {
          console.log('Ré”®è¢«æŒ‰ä¸‹ï¼Œå½“å‰æ¸¸æˆçŠ¶æ€:', gameState);
        }
        
        // æš‚åœèœå•
        if (down && k === 'escape') {
          togglePause();
          return;
        }
        
        // é‡æ–°å¼€å§‹ï¼ˆåœ¨æ¸¸æˆè¿›è¡Œä¸­æˆ–æ¸¸æˆç»“æŸæ—¶éƒ½å¯ä»¥ï¼‰
        if (down && k === 'r' && (gameState === 'playing' || gameState === 'gameOver' || gameState === 'victory')) {
          console.log('å‡†å¤‡é‡æ–°å¼€å§‹æ¸¸æˆ');
          restartLevel();
          return;
        }
        
        // åªåœ¨æ¸¸æˆè¿›è¡Œä¸­å¤„ç†ç§»åŠ¨å’Œå°„å‡»
        if (gameState !== 'playing') return;
        
        if(['w','arrowup'].includes(k)) input.up = down;
        if(['s','arrowdown'].includes(k)) input.down = down;
        if(['a','arrowleft'].includes(k)) input.left = down;
        if(['d','arrowright'].includes(k)) input.right = down;
        setHUD('keys', Object.entries(input).filter(([,v])=>v).map(([k])=>k).join(', ') || '-');
        if (down && (k === 'j' || k === ' ')) fire();
      }
      addEventListener('keydown', e=>setKey(e,true));
      addEventListener('keyup', e=>setKey(e,false));

      async function loadLevel(id){
        currentLevelId = id;
        const res = await fetch(`/api/level/${id}`);
        level = await res.json();
        const ts = level.tile_size;
        const [gw, gh] = level.size;
        // è°ƒæ•´ç”»å¸ƒå¤§å°ä»¥å®Œæ•´æ˜¾ç¤ºåœ°å›¾
        const mapWidth = gw * ts;
        const mapHeight = gh * ts;
        mapPixelWidth = mapWidth;
        mapPixelHeight = mapHeight;
        resizeViewport(mapWidth, mapHeight, { adjustExisting: false });
        // ç©å®¶å‡ºç”Ÿç‚¹ï¼ˆè½¬æ¢åˆ°ç”»å¸ƒåæ ‡ï¼‰
        tank.x = levelOffsetX + level.player_spawn[0]*ts + ts/2;
        tank.y = levelOffsetY + level.player_spawn[1]*ts + ts/2;
        
        // åŠ è½½æ•Œäººç±»å‹é…ç½®
        const enemyRes = await fetch('/api/enemy_types');
        enemyTypes = await enemyRes.json();
        
        // åˆå§‹åŒ–æ•Œäººæ³¢æ¬¡
        enemyWaves = level.enemy_waves || [];
        currentWave = 0;
        waveTimer = 0;
        enemiesSpawned = 0;
        enemies.splice(0); // æ¸…ç©ºæ•Œäººæ•°ç»„
        
        // åˆå§‹åŒ–åŸºåœ°
        const [baseGx, baseGy] = level.base;
        base = {
          x: levelOffsetX + baseGx * ts + ts/2,
          y: levelOffsetY + baseGy * ts + ts/2,
          w: ts,
          h: ts,
          health: 1,
          maxHealth: 1
        };
        
        // é‡ç½®æ¸¸æˆçŠ¶æ€
        gameState = 'playing';
        playerLives = 3;
        score = 0;
      }

      // åŠ è½½éŸ³é¢‘è®¾ç½®
      loadAudioSettings();
      
      loadLevel(currentLevelId).then(()=>requestAnimationFrame(loop));

      function fire(){
        if (tank.fireCooldown > 0) return;
        tank.fireCooldown = 0.25; // 4 å‘/ç§’
        const speed = 260;
        let vx = 0, vy = 0;
        if (tank.dir === 'up') vy = -speed;
        if (tank.dir === 'down') vy = speed;
        if (tank.dir === 'left') vx = -speed;
        if (tank.dir === 'right') vx = speed;
        bullets.push({ x: tank.x, y: tank.y, vx, vy, owner: 'player' });
        
        // æ’­æ”¾å°„å‡»éŸ³æ•ˆ
        generateShootSound();
      }

      function checkBulletCollision(b){
        if (!level) return false;
        const ts = level.tile_size; const [gw, gh] = level.size;
        const ox = levelOffsetX; const oy = levelOffsetY;
        const gx = Math.floor((b.x - ox) / ts);
        const gy = Math.floor((b.y - oy) / ts);
        
        // è°ƒè¯•ä¿¡æ¯
        console.log(`å­å¼¹ä½ç½®: (${b.x.toFixed(1)}, ${b.y.toFixed(1)})`);
        console.log(`åœ°å›¾åç§»: (${ox}, ${oy})`);
        console.log(`ç“¦ç‰‡åæ ‡: (${gx}, ${gy})`);
        
        if (gx < 0 || gy < 0 || gx >= gw || gy >= gh) {
          console.log('å­å¼¹è¶…å‡ºåœ°å›¾è¾¹ç•Œ');
          return false;
        }
        
        const t = level.tiles[gy][gx];
        console.log(`ç“¦ç‰‡ç±»å‹: ${t}`);
        
        if (t === 'brick') {
          console.log('å­å¼¹å‡»ä¸­ç –å—ï¼');
          // åˆå§‹åŒ–ç –å—è€ä¹…åº¦ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
          if (!level.tile_health) {
            level.tile_health = {};
          }
          const tileKey = `${gx},${gy}`;
          if (!level.tile_health[tileKey]) {
            level.tile_health[tileKey] = 3; // é»˜è®¤3ç‚¹è€ä¹…åº¦
          }
          
          // æ ¹æ®å­å¼¹æ‰€æœ‰è€…å‡å°‘è€ä¹…åº¦
          if (b.owner === 'player') {
            level.tile_health[tileKey] -= 3; // ç©å®¶ä¸€å‘å°±èƒ½æ‰“å
            console.log(`ç©å®¶å­å¼¹å‡»ä¸­ç –å—ï¼Œè€ä¹…åº¦: ${level.tile_health[tileKey]}`);
          } else {
            level.tile_health[tileKey] -= 1; // æ•Œäººéœ€è¦3å‘
            console.log(`æ•Œäººå­å¼¹å‡»ä¸­ç –å—ï¼Œè€ä¹…åº¦: ${level.tile_health[tileKey]}`);
          }
          
          // æ£€æŸ¥æ˜¯å¦è¢«ç ´å
          if (level.tile_health[tileKey] <= 0) {
            level.tiles[gy][gx] = 'ground';
            delete level.tile_health[tileKey];
            console.log('ç –å—è¢«ç ´åï¼');
            // åˆ›å»ºç –å—ç ´åç‰¹æ•ˆ
            const brickX = ox + gx * ts + ts / 2;
            const brickY = oy + gy * ts + ts / 2;
            createExplosion(brickX, brickY, 'brick', '#b45309');
          }
          return true;
        }
        
        if (t === 'steel' || t === 'water') { 
          console.log(`å­å¼¹å‡»ä¸­${t === 'steel' ? 'é’¢æ¿' : 'æ°´é¢'}ï¼`);
          // é’¢æ¿å‡»ä¸­æ—¶äº§ç”Ÿå°ç«èŠ±
          if (t === 'steel') {
            const steelX = ox + gx * ts + ts / 2;
            const steelY = oy + gy * ts + ts / 2;
            createParticles(steelX, steelY, 4, '#94a3b8', 'brick');
          }
          return true; 
        }
        
        console.log('å­å¼¹æ²¡æœ‰å‡»ä¸­ä»»ä½•é˜»æŒ¡ç‰©');
        return false;
      }

      function isSolidTile(t){
        return t === 'brick' || t === 'steel' || t === 'water';
      }

      function willCollide(nextX, nextY){
        if (!level) return false;
        const ts = level.tile_size; const [gw, gh] = level.size;
        const ox = levelOffsetX; const oy = levelOffsetY;
        const halfW = tank.w/2, halfH = tank.h/2;
        const minX = nextX - halfW, maxX = nextX + halfW;
        const minY = nextY - halfH, maxY = nextY + halfH;
        // é™åˆ¶åœ¨åœ°å›¾åŒ…å›´ç›’å†…
        const mapMinX = ox, mapMinY = oy, mapMaxX = ox + gw*ts, mapMaxY = oy + gh*ts;
        if (maxX <= mapMinX || minX >= mapMaxX || maxY <= mapMinY || minY >= mapMaxY) return false;
        const gx0 = Math.floor((Math.max(minX, mapMinX) - ox) / ts);
        const gx1 = Math.floor((Math.min(maxX, mapMaxX) - 0.001 - ox) / ts);
        const gy0 = Math.floor((Math.max(minY, mapMinY) - oy) / ts);
        const gy1 = Math.floor((Math.min(maxY, mapMaxY) - 0.001 - oy) / ts);
        for(let y=gy0; y<=gy1; y++){
          for(let x=gx0; x<=gx1; x++){
            if (x<0||y<0||x>=gw||y>=gh) continue;
            if (isSolidTile(level.tiles[y][x])) return true;
          }
        }
        return false;
      }

      function checkBulletUnitCollision(b) {
        // ç©å®¶å­å¼¹å‡»ä¸­æ•Œäºº
        if (b.owner === 'player') {
          for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            if (isColliding(b, enemy)) {
              // åˆ›å»ºå‘½ä¸­ç‰¹æ•ˆï¼ˆå°ç«èŠ±ï¼‰
              createParticles(b.x, b.y, 6, enemy.color, 'small');
              
              enemy.health--;
              
              // å¦‚æœæ•Œäººå³å°†æ­»äº¡ï¼Œä¸åœ¨è¿™é‡Œåˆ›å»ºçˆ†ç‚¸ï¼ˆåœ¨æ•Œäººæ›´æ–°å¾ªç¯ä¸­ç»Ÿä¸€å¤„ç†ï¼‰
              return true;
            }
          }
        }
        
        // æ•Œäººå­å¼¹å‡»ä¸­ç©å®¶
        if (b.owner === 'enemy') {
          if (isColliding(b, tank)) {
            // åˆ›å»ºç©å®¶å—å‡»ç‰¹æ•ˆ
            createExplosion(tank.x, tank.y, 'medium', '#38bdf8');
            triggerScreenShake(6, 0.25);
            
            playerLives--;
            if (playerLives <= 0) {
              // ç©å®¶æ­»äº¡ï¼Œåˆ›å»ºå¤§çˆ†ç‚¸
              createExplosion(tank.x, tank.y, 'large', '#ef4444');
              gameState = 'gameOver';
            }
            return true;
          }
          
          // æ•Œäººå­å¼¹å‡»ä¸­åŸºåœ°
          if (base && isColliding(b, base)) {
            // åˆ›å»ºåŸºåœ°å—å‡»ç‰¹æ•ˆ
            createExplosion(base.x, base.y, 'medium', '#fbbf24');
            triggerScreenShake(8, 0.3);
            
            base.health--;
            if (base.health <= 0) {
              // åŸºåœ°è¢«æ‘§æ¯ï¼Œåˆ›å»ºå¤§çˆ†ç‚¸
              createExplosion(base.x, base.y, 'large', '#ef4444');
              triggerScreenShake(12, 0.5);
              gameState = 'gameOver';
            }
            return true;
          }
        }
        
        return false;
      }

      function isColliding(bullet, unit) {
        const dx = bullet.x - unit.x;
        const dy = bullet.y - unit.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (unit.w / 2 + 2); // å­å¼¹åŠå¾„ + å•ä½åŠå¾„
      }
      
      // æ£€æŸ¥å­å¼¹å¯¹æ’
      function checkBulletToBulletCollision() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet1 = bullets[i];
          
          for (let j = bullets.length - 1; j > i; j--) {
            const bullet2 = bullets[j];
            
            // åªæœ‰ä¸åŒä¸»äººçš„å­å¼¹æ‰èƒ½å¯¹æ’
            if (bullet1.owner !== bullet2.owner) {
              if (isColliding(bullet1, bullet2)) {
                // åˆ›å»ºå­å¼¹å¯¹æ’ç‰¹æ•ˆ
                const collisionX = (bullet1.x + bullet2.x) / 2;
                const collisionY = (bullet1.y + bullet2.y) / 2;
                createExplosion(collisionX, collisionY, 'small', '#60a5fa');
                
                // ä¸¤ä¸ªå­å¼¹éƒ½æ¶ˆå¤±
                bullets.splice(j, 1);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }
      }

      // æ•Œäººç”Ÿæˆç³»ç»Ÿ
      function updateEnemySpawning(dt) {
        if (currentWave >= enemyWaves.length) return;
        
        const wave = enemyWaves[currentWave];
        waveTimer += dt;
        
        if (waveTimer >= wave.interval && enemiesSpawned < wave.count && enemies.length < level.max_enemies_on_screen) {
          spawnEnemy(wave.type);
          enemiesSpawned++;
          waveTimer = 0;
        }
        
        // æ£€æŸ¥å½“å‰æ³¢æ¬¡æ˜¯å¦å®Œæˆ
        if (enemiesSpawned >= wave.count && enemies.length === 0) {
          currentWave++;
          waveTimer = 0;
          enemiesSpawned = 0;
        }
      }

      function spawnEnemy(type) {
        const config = enemyTypes[type];
        if (!config) return;
        
        // éšæœºé€‰æ‹©ç”Ÿæˆç‚¹
        const spawnPoints = level.enemy_spawns;
        const spawnIndex = Math.floor(Math.random() * spawnPoints.length);
        const [gx, gy] = spawnPoints[spawnIndex];
        const ts = level.tile_size;
        
        // è®¡ç®—æ•Œäººç”Ÿæˆä½ç½®ï¼ˆåªä»é¡¶éƒ¨ç”Ÿæˆï¼‰
        const enemyX = levelOffsetX + gx * ts + ts/2;
        const enemyY = levelOffsetY + gy * ts + ts/2;
        
        const enemy = {
          x: enemyX,
          y: enemyY,
          w: config.size,
          h: config.size,
          speed: config.speed,
          health: config.health,
          maxHealth: config.health,
          fireRate: config.fire_rate,
          fireCooldown: 0,
          dir: 'down', // é»˜è®¤å‘ä¸‹
          type: type,
          color: config.color,
          aiTimer: 0,
          aiState: 'patrol' // patrol, chase, attack
        };
        
        enemies.push(enemy);
      }

      function updateEnemy(enemy, dt) {
        // æ›´æ–°å°„å‡»å†·å´
        enemy.fireCooldown = Math.max(0, enemy.fireCooldown - dt);
        
        // ç®€å• AIï¼šéšæœºç§»åŠ¨ + å¶å°”å°„å‡»
        enemy.aiTimer += dt;
        
        if (enemy.aiTimer > 1.0) { // æ¯ç§’æ”¹å˜ä¸€æ¬¡è¡Œä¸º
          const actions = ['move', 'shoot'];
          const action = actions[Math.floor(Math.random() * actions.length)];
          
          if (action === 'move') {
            const dirs = ['up', 'down', 'left', 'right'];
            enemy.dir = dirs[Math.floor(Math.random() * dirs.length)];
          } else if (action === 'shoot' && enemy.fireCooldown <= 0) {
            enemyFire(enemy);
          }
          
          enemy.aiTimer = 0;
        }
        
        // ç§»åŠ¨
        const dx = (enemy.dir === 'right' ? 1 : enemy.dir === 'left' ? -1 : 0) * enemy.speed * dt;
        const dy = (enemy.dir === 'down' ? 1 : enemy.dir === 'up' ? -1 : 0) * enemy.speed * dt;
        
        // è¾¹ç•Œæ£€æµ‹ï¼šç¡®ä¿æ•Œäººå¦å…‹ä¸ä¼šè¶…å‡ºç”»å¸ƒè¾¹ç•Œ
        let nextX = enemy.x + dx;
        nextX = Math.max(enemy.w/2, Math.min(canvas.width - enemy.w/2, nextX));
        if (!willEnemyCollide(nextX, enemy.y, enemy)) enemy.x = nextX;
        
        let nextY = enemy.y + dy;
        nextY = Math.max(enemy.h/2, Math.min(canvas.height - enemy.h/2, nextY));
        if (!willEnemyCollide(enemy.x, nextY, enemy)) enemy.y = nextY;
      }

      function drawEnemy(enemy) {
        ctx.save();
        ctx.translate(enemy.x, enemy.y);
        ctx.rotate(enemy.dir === 'up' ? 0 : enemy.dir === 'down' ? Math.PI : enemy.dir === 'left' ? -Math.PI/2 : Math.PI/2);
        
        const w = enemy.w;
        const h = enemy.h;
        const enemyType = enemy.type || 'normal';
        
        // æ ¹æ®æ•Œäººç±»å‹è®¾ç½®é¢œè‰²
        let mainColor, accentColor, borderColor;
        switch(enemyType) {
          case 'fast':
            mainColor = '#f97316';
            accentColor = '#ea580c';
            borderColor = '#c2410c';
            break;
          case 'heavy':
            mainColor = '#6b7280';
            accentColor = '#4b5563';
            borderColor = '#374151';
            break;
          case 'special':
            mainColor = '#8b5cf6';
            accentColor = '#7c3aed';
            borderColor = '#6d28d9';
            break;
          default: // normal
            mainColor = '#ef4444';
            accentColor = '#dc2626';
            borderColor = '#b91c1c';
        }
        
        // ä¸»ä½“æ¸å˜
        const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
        gradient.addColorStop(0, mainColor);
        gradient.addColorStop(0.5, accentColor);
        gradient.addColorStop(1, borderColor);
        ctx.fillStyle = gradient;
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // è¾¹æ¡†
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(-w/2, -h/2, w, h);
        
        // å†…éƒ¨ç»†èŠ‚
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(-w/2 + 3, -h/2 + 3, w - 6, h - 6);
        
        // ç‚®ç®¡
        ctx.fillStyle = '#374151';
        ctx.fillRect(-2, -h/2 - 4, 4, 8);
        
        // ç‚®ç®¡å°–ç«¯
        ctx.fillStyle = '#6b7280';
        ctx.fillRect(-1, -h/2 - 6, 2, 4);
        
        // å±¥å¸¦ç»†èŠ‚
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(-w/2 + 2, -h/2 + 1, w - 4, 2);
        ctx.fillRect(-w/2 + 2, h/2 - 3, w - 4, 2);
        
        // æ•Œäººç±»å‹æ ‡è¯†
        ctx.fillStyle = '#ffffff';
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        const typeSymbol = enemyType === 'fast' ? 'F' : 
                         enemyType === 'heavy' ? 'H' : 
                         enemyType === 'special' ? 'S' : 'N';
        ctx.fillText(typeSymbol, 0, 2);
        
        ctx.restore();
        
        // ç»˜åˆ¶ç”Ÿå‘½æ¡ï¼ˆå¦‚æœå—ä¼¤ï¼‰
        if (enemy.health < enemy.maxHealth) {
          const barWidth = enemy.w;
          const barHeight = 4;
          const healthPercent = enemy.health / enemy.maxHealth;
          
          // ç”Ÿå‘½æ¡èƒŒæ™¯
          ctx.fillStyle = '#ef4444';
          ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.h/2 - 8, barWidth, barHeight);
          
          // ç”Ÿå‘½æ¡å‰æ™¯
          ctx.fillStyle = '#22c55e';
          ctx.fillRect(enemy.x - barWidth/2, enemy.y - enemy.h/2 - 8, barWidth * healthPercent, barHeight);
        }
      }

      function enemyFire(enemy) {
        if (enemy.fireCooldown > 0) return;
        
        enemy.fireCooldown = 1.0 / enemy.fireRate;
        const speed = 200;
        let vx = 0, vy = 0;
        
        if (enemy.dir === 'up') vy = -speed;
        if (enemy.dir === 'down') vy = speed;
        if (enemy.dir === 'left') vx = -speed;
        if (enemy.dir === 'right') vx = speed;
        
        bullets.push({ 
          x: enemy.x, 
          y: enemy.y, 
          vx, 
          vy, 
          owner: 'enemy' // æ ‡è®°ä¸ºæ•Œäººå­å¼¹
        });
      }

      function willEnemyCollide(nextX, nextY, enemy) {
        if (!level) return false;
        const ts = level.tile_size; 
        const [gw, gh] = level.size;
        const ox = levelOffsetX; 
        const oy = levelOffsetY;
        const halfW = enemy.w/2, halfH = enemy.h/2;
        const minX = nextX - halfW, maxX = nextX + halfW;
        const minY = nextY - halfH, maxY = nextY + halfH;
        
        // é™åˆ¶åœ¨åœ°å›¾åŒ…å›´ç›’å†…
        const mapMinX = ox, mapMinY = oy, mapMaxX = ox + gw*ts, mapMaxY = oy + gh*ts;
        if (maxX <= mapMinX || minX >= mapMaxX || maxY <= mapMinY || minY >= mapMaxY) return false;
        
        const gx0 = Math.floor((Math.max(minX, mapMinX) - ox) / ts);
        const gx1 = Math.floor((Math.min(maxX, mapMaxX) - 0.001 - ox) / ts);
        const gy0 = Math.floor((Math.max(minY, mapMinY) - oy) / ts);
        const gy1 = Math.floor((Math.min(maxY, mapMaxY) - 0.001 - oy) / ts);
        
        for(let y=gy0; y<=gy1; y++){
          for(let x=gx0; x<=gx1; x++){
            if (x<0||y<0||x>=gw||y>=gh) continue;
            if (isSolidTile(level.tiles[y][x])) return true;
          }
        }
        return false;
      }

      function drawBase() {
        if (!base) return;
        
        ctx.save();
        ctx.translate(base.x, base.y);
        
        const w = base.w;
        const h = base.h;
        
        // åŸºåœ°ä¸»ä½“ - ç°ä»£åŒ–è®¾è®¡
        if (base.health > 0) {
          // å¥åº·çŠ¶æ€ - é‡‘è‰²æ¸å˜
          const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
          gradient.addColorStop(0, '#fbbf24');
          gradient.addColorStop(0.5, '#f59e0b');
          gradient.addColorStop(1, '#d97706');
          ctx.fillStyle = gradient;
        } else {
          // è¢«æ‘§æ¯çŠ¶æ€ - çº¢è‰²æ¸å˜
          const gradient = ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
          gradient.addColorStop(0, '#ef4444');
          gradient.addColorStop(0.5, '#dc2626');
          gradient.addColorStop(1, '#b91c1c');
          ctx.fillStyle = gradient;
        }
        
        // ç»˜åˆ¶ä¸»ä½“
        ctx.fillRect(-w/2, -h/2, w, h);
        
        // è¾¹æ¡†
        ctx.strokeStyle = base.health > 0 ? '#d97706' : '#b91c1c';
        ctx.lineWidth = 2;
        ctx.strokeRect(-w/2, -h/2, w, h);
        
        // å†…éƒ¨ç»†èŠ‚
        ctx.fillStyle = '#1e293b';
        ctx.fillRect(-w/2 + 3, -h/2 + 3, w - 6, h - 6);
        
        // ç»˜åˆ¶é¹°æ ‡ï¼ˆæ›´ç°ä»£åŒ–ï¼‰
        ctx.fillStyle = base.health > 0 ? '#fbbf24' : '#ef4444';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('â˜…', 0, 0);
        
        // æ·»åŠ å‘å…‰æ•ˆæœ
        if (base.health > 0) {
          ctx.shadowColor = '#fbbf24';
          ctx.shadowBlur = 8;
          ctx.fillText('â˜…', 0, 0);
        }
        
        ctx.restore();
        
        // ç»˜åˆ¶ç”Ÿå‘½æ¡ï¼ˆå¦‚æœå—ä¼¤ï¼‰
        if (base.health < base.maxHealth) {
          const barWidth = base.w;
          const barHeight = 4;
          const healthPercent = base.health / base.maxHealth;
          
          // ç”Ÿå‘½æ¡èƒŒæ™¯
          ctx.fillStyle = '#ef4444';
          ctx.fillRect(base.x - barWidth/2, base.y - base.h/2 - 8, barWidth, barHeight);
          
          // ç”Ÿå‘½æ¡å‰æ™¯
          ctx.fillStyle = '#22c55e';
          ctx.fillRect(base.x - barWidth/2, base.y - base.h/2 - 8, barWidth * healthPercent, barHeight);
        }
      }

      function checkGameState() {
        // æ£€æŸ¥å¤±è´¥æ¡ä»¶ï¼šç©å®¶ç”Ÿå‘½ä¸º0æˆ–åŸºåœ°è¢«æ‘§æ¯
        if (playerLives <= 0 || (base && base.health <= 0)) {
          if (gameState === 'playing') {
            gameState = 'gameOver';
            generateGameOverSound();
          }
          return;
        }
        
        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶ï¼šæ‰€æœ‰æ³¢æ¬¡å®Œæˆä¸”æ— æ•Œäºº
        if (currentWave >= enemyWaves.length && enemies.length === 0 && gameState === 'playing') {
          gameState = 'victory';
          generateVictorySound();
        }
      }

      function getEnemyScore(type) {
        const scores = {
          'normal': 100,
          'fast': 150,
          'heavy': 200,
          'special': 300
        };
        return scores[type] || 100;
      }

      function drawGameState() {
        // åŠé€æ˜èƒŒæ™¯
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // çŠ¶æ€æ–‡å­—
        ctx.fillStyle = '#ffffff';
        ctx.font = '32px Arial';
        ctx.textAlign = 'center';
        
        if (gameState === 'gameOver') {
          ctx.fillText('æ¸¸æˆç»“æŸ', canvas.width/2, canvas.height/2 - 20);
          ctx.font = '16px Arial';
          ctx.fillText(`æœ€ç»ˆå¾—åˆ†: ${score}`, canvas.width/2, canvas.height/2 + 20);
          ctx.fillText('æŒ‰ R é‡æ–°å¼€å§‹', canvas.width/2, canvas.height/2 + 50);
        } else if (gameState === 'victory') {
          ctx.fillText('èƒœåˆ©ï¼', canvas.width/2, canvas.height/2 - 20);
          ctx.font = '16px Arial';
          ctx.fillText(`å¾—åˆ†: ${score}`, canvas.width/2, canvas.height/2 + 20);
          ctx.fillText('æŒ‰ R é‡æ–°å¼€å§‹', canvas.width/2, canvas.height/2 + 50);
        } else if (gameState === 'paused') {
          ctx.fillText('æ¸¸æˆæš‚åœ', canvas.width/2, canvas.height/2 - 20);
          ctx.font = '16px Arial';
          ctx.fillText('æŒ‰ ESC ç»§ç»­æ¸¸æˆ', canvas.width/2, canvas.height/2 + 20);
          ctx.fillText('æŒ‰ R é‡æ–°å¼€å§‹', canvas.width/2, canvas.height/2 + 50);
        }
      }

      function updateHUD() {
        setHUD('lives', playerLives);
        setHUD('score', score);
        setHUD('level', level ? level.id : 1);
        setHUD('enemies', enemies.length);
        const waveDisplay = enemyWaves.length ? `${Math.min(currentWave + 1, enemyWaves.length)}/${enemyWaves.length}` : '--';
        setHUD('wave', waveDisplay);
      }

      function togglePause() {
        if (gameState === 'playing') {
          gameState = 'paused';
        } else if (gameState === 'paused') {
          gameState = 'playing';
        }
      }

      function restartLevel() {
        console.log('restartLevel è¢«è°ƒç”¨ï¼Œå½“å‰æ¸¸æˆçŠ¶æ€:', gameState);
        if (confirm('ç¡®å®šè¦é‡æ–°å¼€å§‹å½“å‰å…³å¡å—ï¼Ÿ')) {
          // æ¸…ç©ºå­å¼¹æ•°ç»„
          bullets.splice(0);
          
          // é‡æ–°åŠ è½½å…³å¡ï¼ˆloadLevel ä¼šé‡ç½®æ‰€æœ‰çŠ¶æ€ï¼‰
          loadLevel(currentLevelId).then(() => {
            console.log('å…³å¡é‡æ–°å¼€å§‹å®Œæˆ');
          });
        }
      }
    </script>
  </body>
  </html>
